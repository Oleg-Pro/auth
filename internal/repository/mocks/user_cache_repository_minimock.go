// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Oleg-Pro/auth/internal/repository.UserCacheRepository -o user_cache_repository_minimock.go -n UserCacheRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Oleg-Pro/auth/internal/model"
	mm_repository "github.com/Oleg-Pro/auth/internal/repository"
	"github.com/gojuno/minimock/v3"
)

// UserCacheRepositoryMock implements mm_repository.UserCacheRepository
type UserCacheRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, id int64, info *model.UserInfo) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, id int64, info *model.UserInfo)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mUserCacheRepositoryMockCreate

	funcDelete          func(ctx context.Context, id int64) (i1 int64, err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mUserCacheRepositoryMockDelete

	funcGet          func(ctx context.Context, filter mm_repository.UserFilter) (up1 *model.User, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, filter mm_repository.UserFilter)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mUserCacheRepositoryMockGet

	funcUpdate          func(ctx context.Context, id int64, info *model.UserUpdateInfo) (i1 int64, err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, id int64, info *model.UserUpdateInfo)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mUserCacheRepositoryMockUpdate
}

// NewUserCacheRepositoryMock returns a mock for mm_repository.UserCacheRepository
func NewUserCacheRepositoryMock(t minimock.Tester) *UserCacheRepositoryMock {
	m := &UserCacheRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mUserCacheRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*UserCacheRepositoryMockCreateParams{}

	m.DeleteMock = mUserCacheRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*UserCacheRepositoryMockDeleteParams{}

	m.GetMock = mUserCacheRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*UserCacheRepositoryMockGetParams{}

	m.UpdateMock = mUserCacheRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*UserCacheRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserCacheRepositoryMockCreate struct {
	optional           bool
	mock               *UserCacheRepositoryMock
	defaultExpectation *UserCacheRepositoryMockCreateExpectation
	expectations       []*UserCacheRepositoryMockCreateExpectation

	callArgs []*UserCacheRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserCacheRepositoryMockCreateExpectation specifies expectation struct of the UserCacheRepository.Create
type UserCacheRepositoryMockCreateExpectation struct {
	mock               *UserCacheRepositoryMock
	params             *UserCacheRepositoryMockCreateParams
	paramPtrs          *UserCacheRepositoryMockCreateParamPtrs
	expectationOrigins UserCacheRepositoryMockCreateExpectationOrigins
	results            *UserCacheRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// UserCacheRepositoryMockCreateParams contains parameters of the UserCacheRepository.Create
type UserCacheRepositoryMockCreateParams struct {
	ctx  context.Context
	id   int64
	info *model.UserInfo
}

// UserCacheRepositoryMockCreateParamPtrs contains pointers to parameters of the UserCacheRepository.Create
type UserCacheRepositoryMockCreateParamPtrs struct {
	ctx  *context.Context
	id   *int64
	info **model.UserInfo
}

// UserCacheRepositoryMockCreateResults contains results of the UserCacheRepository.Create
type UserCacheRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// UserCacheRepositoryMockCreateOrigins contains origins of expectations of the UserCacheRepository.Create
type UserCacheRepositoryMockCreateExpectationOrigins struct {
	origin     string
	originCtx  string
	originId   string
	originInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mUserCacheRepositoryMockCreate) Optional() *mUserCacheRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for UserCacheRepository.Create
func (mmCreate *mUserCacheRepositoryMockCreate) Expect(ctx context.Context, id int64, info *model.UserInfo) *mUserCacheRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserCacheRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserCacheRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("UserCacheRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &UserCacheRepositoryMockCreateParams{ctx, id, info}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for UserCacheRepository.Create
func (mmCreate *mUserCacheRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mUserCacheRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserCacheRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserCacheRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UserCacheRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UserCacheRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectIdParam2 sets up expected param id for UserCacheRepository.Create
func (mmCreate *mUserCacheRepositoryMockCreate) ExpectIdParam2(id int64) *mUserCacheRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserCacheRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserCacheRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UserCacheRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UserCacheRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.id = &id
	mmCreate.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectInfoParam3 sets up expected param info for UserCacheRepository.Create
func (mmCreate *mUserCacheRepositoryMockCreate) ExpectInfoParam3(info *model.UserInfo) *mUserCacheRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserCacheRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserCacheRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UserCacheRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UserCacheRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.info = &info
	mmCreate.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the UserCacheRepository.Create
func (mmCreate *mUserCacheRepositoryMockCreate) Inspect(f func(ctx context.Context, id int64, info *model.UserInfo)) *mUserCacheRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for UserCacheRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by UserCacheRepository.Create
func (mmCreate *mUserCacheRepositoryMockCreate) Return(i1 int64, err error) *UserCacheRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserCacheRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserCacheRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &UserCacheRepositoryMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the UserCacheRepository.Create method
func (mmCreate *mUserCacheRepositoryMockCreate) Set(f func(ctx context.Context, id int64, info *model.UserInfo) (i1 int64, err error)) *UserCacheRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the UserCacheRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the UserCacheRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the UserCacheRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mUserCacheRepositoryMockCreate) When(ctx context.Context, id int64, info *model.UserInfo) *UserCacheRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserCacheRepositoryMock.Create mock is already set by Set")
	}

	expectation := &UserCacheRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &UserCacheRepositoryMockCreateParams{ctx, id, info},
		expectationOrigins: UserCacheRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up UserCacheRepository.Create return parameters for the expectation previously defined by the When method
func (e *UserCacheRepositoryMockCreateExpectation) Then(i1 int64, err error) *UserCacheRepositoryMock {
	e.results = &UserCacheRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times UserCacheRepository.Create should be invoked
func (mmCreate *mUserCacheRepositoryMockCreate) Times(n uint64) *mUserCacheRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of UserCacheRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mUserCacheRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.UserCacheRepository
func (mmCreate *UserCacheRepositoryMock) Create(ctx context.Context, id int64, info *model.UserInfo) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, id, info)
	}

	mm_params := UserCacheRepositoryMockCreateParams{ctx, id, info}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := UserCacheRepositoryMockCreateParams{ctx, id, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("UserCacheRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmCreate.t.Errorf("UserCacheRepositoryMock.Create got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmCreate.t.Errorf("UserCacheRepositoryMock.Create got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("UserCacheRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the UserCacheRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, id, info)
	}
	mmCreate.t.Fatalf("Unexpected call to UserCacheRepositoryMock.Create. %v %v %v", ctx, id, info)
	return
}

// CreateAfterCounter returns a count of finished UserCacheRepositoryMock.Create invocations
func (mmCreate *UserCacheRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of UserCacheRepositoryMock.Create invocations
func (mmCreate *UserCacheRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to UserCacheRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mUserCacheRepositoryMockCreate) Calls() []*UserCacheRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*UserCacheRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *UserCacheRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *UserCacheRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to UserCacheRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCacheRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mUserCacheRepositoryMockDelete struct {
	optional           bool
	mock               *UserCacheRepositoryMock
	defaultExpectation *UserCacheRepositoryMockDeleteExpectation
	expectations       []*UserCacheRepositoryMockDeleteExpectation

	callArgs []*UserCacheRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserCacheRepositoryMockDeleteExpectation specifies expectation struct of the UserCacheRepository.Delete
type UserCacheRepositoryMockDeleteExpectation struct {
	mock               *UserCacheRepositoryMock
	params             *UserCacheRepositoryMockDeleteParams
	paramPtrs          *UserCacheRepositoryMockDeleteParamPtrs
	expectationOrigins UserCacheRepositoryMockDeleteExpectationOrigins
	results            *UserCacheRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// UserCacheRepositoryMockDeleteParams contains parameters of the UserCacheRepository.Delete
type UserCacheRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// UserCacheRepositoryMockDeleteParamPtrs contains pointers to parameters of the UserCacheRepository.Delete
type UserCacheRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserCacheRepositoryMockDeleteResults contains results of the UserCacheRepository.Delete
type UserCacheRepositoryMockDeleteResults struct {
	i1  int64
	err error
}

// UserCacheRepositoryMockDeleteOrigins contains origins of expectations of the UserCacheRepository.Delete
type UserCacheRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mUserCacheRepositoryMockDelete) Optional() *mUserCacheRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for UserCacheRepository.Delete
func (mmDelete *mUserCacheRepositoryMockDelete) Expect(ctx context.Context, id int64) *mUserCacheRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserCacheRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserCacheRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("UserCacheRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &UserCacheRepositoryMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for UserCacheRepository.Delete
func (mmDelete *mUserCacheRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mUserCacheRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserCacheRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserCacheRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserCacheRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserCacheRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for UserCacheRepository.Delete
func (mmDelete *mUserCacheRepositoryMockDelete) ExpectIdParam2(id int64) *mUserCacheRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserCacheRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserCacheRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserCacheRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserCacheRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the UserCacheRepository.Delete
func (mmDelete *mUserCacheRepositoryMockDelete) Inspect(f func(ctx context.Context, id int64)) *mUserCacheRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for UserCacheRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by UserCacheRepository.Delete
func (mmDelete *mUserCacheRepositoryMockDelete) Return(i1 int64, err error) *UserCacheRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserCacheRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserCacheRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &UserCacheRepositoryMockDeleteResults{i1, err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the UserCacheRepository.Delete method
func (mmDelete *mUserCacheRepositoryMockDelete) Set(f func(ctx context.Context, id int64) (i1 int64, err error)) *UserCacheRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the UserCacheRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the UserCacheRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the UserCacheRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mUserCacheRepositoryMockDelete) When(ctx context.Context, id int64) *UserCacheRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserCacheRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &UserCacheRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &UserCacheRepositoryMockDeleteParams{ctx, id},
		expectationOrigins: UserCacheRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up UserCacheRepository.Delete return parameters for the expectation previously defined by the When method
func (e *UserCacheRepositoryMockDeleteExpectation) Then(i1 int64, err error) *UserCacheRepositoryMock {
	e.results = &UserCacheRepositoryMockDeleteResults{i1, err}
	return e.mock
}

// Times sets number of times UserCacheRepository.Delete should be invoked
func (mmDelete *mUserCacheRepositoryMockDelete) Times(n uint64) *mUserCacheRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of UserCacheRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mUserCacheRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repository.UserCacheRepository
func (mmDelete *UserCacheRepositoryMock) Delete(ctx context.Context, id int64) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := UserCacheRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := UserCacheRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("UserCacheRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("UserCacheRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("UserCacheRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the UserCacheRepositoryMock.Delete")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to UserCacheRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished UserCacheRepositoryMock.Delete invocations
func (mmDelete *UserCacheRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of UserCacheRepositoryMock.Delete invocations
func (mmDelete *UserCacheRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to UserCacheRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mUserCacheRepositoryMockDelete) Calls() []*UserCacheRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*UserCacheRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *UserCacheRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *UserCacheRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to UserCacheRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCacheRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mUserCacheRepositoryMockGet struct {
	optional           bool
	mock               *UserCacheRepositoryMock
	defaultExpectation *UserCacheRepositoryMockGetExpectation
	expectations       []*UserCacheRepositoryMockGetExpectation

	callArgs []*UserCacheRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserCacheRepositoryMockGetExpectation specifies expectation struct of the UserCacheRepository.Get
type UserCacheRepositoryMockGetExpectation struct {
	mock               *UserCacheRepositoryMock
	params             *UserCacheRepositoryMockGetParams
	paramPtrs          *UserCacheRepositoryMockGetParamPtrs
	expectationOrigins UserCacheRepositoryMockGetExpectationOrigins
	results            *UserCacheRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// UserCacheRepositoryMockGetParams contains parameters of the UserCacheRepository.Get
type UserCacheRepositoryMockGetParams struct {
	ctx    context.Context
	filter mm_repository.UserFilter
}

// UserCacheRepositoryMockGetParamPtrs contains pointers to parameters of the UserCacheRepository.Get
type UserCacheRepositoryMockGetParamPtrs struct {
	ctx    *context.Context
	filter *mm_repository.UserFilter
}

// UserCacheRepositoryMockGetResults contains results of the UserCacheRepository.Get
type UserCacheRepositoryMockGetResults struct {
	up1 *model.User
	err error
}

// UserCacheRepositoryMockGetOrigins contains origins of expectations of the UserCacheRepository.Get
type UserCacheRepositoryMockGetExpectationOrigins struct {
	origin       string
	originCtx    string
	originFilter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mUserCacheRepositoryMockGet) Optional() *mUserCacheRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for UserCacheRepository.Get
func (mmGet *mUserCacheRepositoryMockGet) Expect(ctx context.Context, filter mm_repository.UserFilter) *mUserCacheRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserCacheRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserCacheRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("UserCacheRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &UserCacheRepositoryMockGetParams{ctx, filter}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for UserCacheRepository.Get
func (mmGet *mUserCacheRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mUserCacheRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserCacheRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserCacheRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UserCacheRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UserCacheRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectFilterParam2 sets up expected param filter for UserCacheRepository.Get
func (mmGet *mUserCacheRepositoryMockGet) ExpectFilterParam2(filter mm_repository.UserFilter) *mUserCacheRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserCacheRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserCacheRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UserCacheRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UserCacheRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.filter = &filter
	mmGet.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the UserCacheRepository.Get
func (mmGet *mUserCacheRepositoryMockGet) Inspect(f func(ctx context.Context, filter mm_repository.UserFilter)) *mUserCacheRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for UserCacheRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by UserCacheRepository.Get
func (mmGet *mUserCacheRepositoryMockGet) Return(up1 *model.User, err error) *UserCacheRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserCacheRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserCacheRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &UserCacheRepositoryMockGetResults{up1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the UserCacheRepository.Get method
func (mmGet *mUserCacheRepositoryMockGet) Set(f func(ctx context.Context, filter mm_repository.UserFilter) (up1 *model.User, err error)) *UserCacheRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the UserCacheRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the UserCacheRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the UserCacheRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mUserCacheRepositoryMockGet) When(ctx context.Context, filter mm_repository.UserFilter) *UserCacheRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserCacheRepositoryMock.Get mock is already set by Set")
	}

	expectation := &UserCacheRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &UserCacheRepositoryMockGetParams{ctx, filter},
		expectationOrigins: UserCacheRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up UserCacheRepository.Get return parameters for the expectation previously defined by the When method
func (e *UserCacheRepositoryMockGetExpectation) Then(up1 *model.User, err error) *UserCacheRepositoryMock {
	e.results = &UserCacheRepositoryMockGetResults{up1, err}
	return e.mock
}

// Times sets number of times UserCacheRepository.Get should be invoked
func (mmGet *mUserCacheRepositoryMockGet) Times(n uint64) *mUserCacheRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of UserCacheRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mUserCacheRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.UserCacheRepository
func (mmGet *UserCacheRepositoryMock) Get(ctx context.Context, filter mm_repository.UserFilter) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, filter)
	}

	mm_params := UserCacheRepositoryMockGetParams{ctx, filter}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := UserCacheRepositoryMockGetParams{ctx, filter}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("UserCacheRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmGet.t.Errorf("UserCacheRepositoryMock.Get got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("UserCacheRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the UserCacheRepositoryMock.Get")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, filter)
	}
	mmGet.t.Fatalf("Unexpected call to UserCacheRepositoryMock.Get. %v %v", ctx, filter)
	return
}

// GetAfterCounter returns a count of finished UserCacheRepositoryMock.Get invocations
func (mmGet *UserCacheRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of UserCacheRepositoryMock.Get invocations
func (mmGet *UserCacheRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to UserCacheRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mUserCacheRepositoryMockGet) Calls() []*UserCacheRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*UserCacheRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *UserCacheRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *UserCacheRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to UserCacheRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCacheRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mUserCacheRepositoryMockUpdate struct {
	optional           bool
	mock               *UserCacheRepositoryMock
	defaultExpectation *UserCacheRepositoryMockUpdateExpectation
	expectations       []*UserCacheRepositoryMockUpdateExpectation

	callArgs []*UserCacheRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserCacheRepositoryMockUpdateExpectation specifies expectation struct of the UserCacheRepository.Update
type UserCacheRepositoryMockUpdateExpectation struct {
	mock               *UserCacheRepositoryMock
	params             *UserCacheRepositoryMockUpdateParams
	paramPtrs          *UserCacheRepositoryMockUpdateParamPtrs
	expectationOrigins UserCacheRepositoryMockUpdateExpectationOrigins
	results            *UserCacheRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// UserCacheRepositoryMockUpdateParams contains parameters of the UserCacheRepository.Update
type UserCacheRepositoryMockUpdateParams struct {
	ctx  context.Context
	id   int64
	info *model.UserUpdateInfo
}

// UserCacheRepositoryMockUpdateParamPtrs contains pointers to parameters of the UserCacheRepository.Update
type UserCacheRepositoryMockUpdateParamPtrs struct {
	ctx  *context.Context
	id   *int64
	info **model.UserUpdateInfo
}

// UserCacheRepositoryMockUpdateResults contains results of the UserCacheRepository.Update
type UserCacheRepositoryMockUpdateResults struct {
	i1  int64
	err error
}

// UserCacheRepositoryMockUpdateOrigins contains origins of expectations of the UserCacheRepository.Update
type UserCacheRepositoryMockUpdateExpectationOrigins struct {
	origin     string
	originCtx  string
	originId   string
	originInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mUserCacheRepositoryMockUpdate) Optional() *mUserCacheRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for UserCacheRepository.Update
func (mmUpdate *mUserCacheRepositoryMockUpdate) Expect(ctx context.Context, id int64, info *model.UserUpdateInfo) *mUserCacheRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserCacheRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserCacheRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("UserCacheRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &UserCacheRepositoryMockUpdateParams{ctx, id, info}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for UserCacheRepository.Update
func (mmUpdate *mUserCacheRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mUserCacheRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserCacheRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserCacheRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UserCacheRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UserCacheRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectIdParam2 sets up expected param id for UserCacheRepository.Update
func (mmUpdate *mUserCacheRepositoryMockUpdate) ExpectIdParam2(id int64) *mUserCacheRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserCacheRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserCacheRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UserCacheRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UserCacheRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.id = &id
	mmUpdate.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectInfoParam3 sets up expected param info for UserCacheRepository.Update
func (mmUpdate *mUserCacheRepositoryMockUpdate) ExpectInfoParam3(info *model.UserUpdateInfo) *mUserCacheRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserCacheRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserCacheRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UserCacheRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UserCacheRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.info = &info
	mmUpdate.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the UserCacheRepository.Update
func (mmUpdate *mUserCacheRepositoryMockUpdate) Inspect(f func(ctx context.Context, id int64, info *model.UserUpdateInfo)) *mUserCacheRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for UserCacheRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by UserCacheRepository.Update
func (mmUpdate *mUserCacheRepositoryMockUpdate) Return(i1 int64, err error) *UserCacheRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserCacheRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserCacheRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &UserCacheRepositoryMockUpdateResults{i1, err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the UserCacheRepository.Update method
func (mmUpdate *mUserCacheRepositoryMockUpdate) Set(f func(ctx context.Context, id int64, info *model.UserUpdateInfo) (i1 int64, err error)) *UserCacheRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the UserCacheRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the UserCacheRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the UserCacheRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mUserCacheRepositoryMockUpdate) When(ctx context.Context, id int64, info *model.UserUpdateInfo) *UserCacheRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserCacheRepositoryMock.Update mock is already set by Set")
	}

	expectation := &UserCacheRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &UserCacheRepositoryMockUpdateParams{ctx, id, info},
		expectationOrigins: UserCacheRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up UserCacheRepository.Update return parameters for the expectation previously defined by the When method
func (e *UserCacheRepositoryMockUpdateExpectation) Then(i1 int64, err error) *UserCacheRepositoryMock {
	e.results = &UserCacheRepositoryMockUpdateResults{i1, err}
	return e.mock
}

// Times sets number of times UserCacheRepository.Update should be invoked
func (mmUpdate *mUserCacheRepositoryMockUpdate) Times(n uint64) *mUserCacheRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of UserCacheRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mUserCacheRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_repository.UserCacheRepository
func (mmUpdate *UserCacheRepositoryMock) Update(ctx context.Context, id int64, info *model.UserUpdateInfo) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, id, info)
	}

	mm_params := UserCacheRepositoryMockUpdateParams{ctx, id, info}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := UserCacheRepositoryMockUpdateParams{ctx, id, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("UserCacheRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdate.t.Errorf("UserCacheRepositoryMock.Update got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmUpdate.t.Errorf("UserCacheRepositoryMock.Update got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("UserCacheRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the UserCacheRepositoryMock.Update")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, id, info)
	}
	mmUpdate.t.Fatalf("Unexpected call to UserCacheRepositoryMock.Update. %v %v %v", ctx, id, info)
	return
}

// UpdateAfterCounter returns a count of finished UserCacheRepositoryMock.Update invocations
func (mmUpdate *UserCacheRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of UserCacheRepositoryMock.Update invocations
func (mmUpdate *UserCacheRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to UserCacheRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mUserCacheRepositoryMockUpdate) Calls() []*UserCacheRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*UserCacheRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *UserCacheRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *UserCacheRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserCacheRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to UserCacheRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to UserCacheRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserCacheRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserCacheRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserCacheRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockUpdateDone()
}
